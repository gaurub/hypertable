/**
 * Autogenerated by Thrift Compiler (1.0.0-dev)
 *
 * DO NOT EDIT UNLESS YOU ARE SURE THAT YOU KNOW WHAT YOU ARE DOING
 *  @generated
 */
package org.hypertable.thriftgen;

import org.apache.thrift.scheme.IScheme;
import org.apache.thrift.scheme.SchemeFactory;
import org.apache.thrift.scheme.StandardScheme;

import org.apache.thrift.scheme.TupleScheme;
import org.apache.thrift.protocol.TTupleProtocol;
import org.apache.thrift.protocol.TProtocolException;
import org.apache.thrift.EncodingUtils;
import org.apache.thrift.TException;
import org.apache.thrift.async.AsyncMethodCallback;
import org.apache.thrift.server.AbstractNonblockingServer.*;
import java.util.List;
import java.util.ArrayList;
import java.util.Map;
import java.util.HashMap;
import java.util.EnumMap;
import java.util.Set;
import java.util.HashSet;
import java.util.EnumSet;
import java.util.Collections;
import java.util.BitSet;
import java.nio.ByteBuffer;
import java.util.Arrays;
import javax.annotation.Generated;
import org.slf4j.Logger;
import org.slf4j.LoggerFactory;

@SuppressWarnings({"cast", "rawtypes", "serial", "unchecked"})
/**
 * Specifies options for a scan
 * 
 * <dl>
 *   <dt>row_intervals</dt>
 *   <dd>A list of ranges of rows to scan. Mutually exclusive with
 *   cell_interval</dd>
 * 
 *   <dt>cell_intervals</dt>
 *   <dd>A list of ranges of cells to scan. Mutually exclusive with
 *   row_intervals</dd>
 * 
 *   <dt>return_deletes</dt>
 *   <dd>Indicates whether cells pending delete are returned</dd>
 * 
 *   <dt>revs</dt>
 *   <dd>Specifies max number of revisions of cells to return</dd>
 * 
 *   <dt>row_limit</dt>
 *   <dd>Specifies max number of rows to return</dd>
 * 
 *   <dt>start_time</dt>
 *   <dd>Specifies start time in nanoseconds since epoch for cells to
 *   return</dd>
 * 
 *   <dt>end_time</dt>
 *   <dd>Specifies end time in nanoseconds since epoch for cells to return</dd>
 * 
 *   <dt>columns</dt>
 *   <dd>Specifies the names of the columns to return</dd>
 * 
 *   <dt>cell_limit</dt>
 *   <dd>Specifies max number of cells to return</dd>
 * 
 *   <dt>cell_limit_per_family</dt>
 *   <dd>Specifies max number of cells to return per column family</dd>
 * 
 *   <dt>row_regexp</dt>
 *   <dd>Specifies a regexp used to filter by rowkey</dd>
 * 
 *   <dt>value_regexp</dt>
 *   <dd>Specifies a regexp used to filter by cell value</dd>
 * 
 *   <dt>scan_and_filter_rows</dt>
 *   <dd>Indicates whether table scan filters the rows specified instead of individual look up</dd>
 * 
 *   <dt>row_offset</dt>
 *   <dd>Specifies number of rows to be skipped</dd>
 * 
 *   <dt>cell_offset</dt>
 *   <dd>Specifies number of cells to be skipped</dd>
 * </dl>
 */
@Generated(value = "Autogenerated by Thrift Compiler (1.0.0-dev)", date = "2014-5-16")
public class ScanSpec implements org.apache.thrift.TBase<ScanSpec, ScanSpec._Fields>, java.io.Serializable, Cloneable, Comparable<ScanSpec> {
  private static final org.apache.thrift.protocol.TStruct STRUCT_DESC = new org.apache.thrift.protocol.TStruct("ScanSpec");

  private static final org.apache.thrift.protocol.TField ROW_INTERVALS_FIELD_DESC = new org.apache.thrift.protocol.TField("row_intervals", org.apache.thrift.protocol.TType.LIST, (short)1);
  private static final org.apache.thrift.protocol.TField CELL_INTERVALS_FIELD_DESC = new org.apache.thrift.protocol.TField("cell_intervals", org.apache.thrift.protocol.TType.LIST, (short)2);
  private static final org.apache.thrift.protocol.TField RETURN_DELETES_FIELD_DESC = new org.apache.thrift.protocol.TField("return_deletes", org.apache.thrift.protocol.TType.BOOL, (short)3);
  private static final org.apache.thrift.protocol.TField VERSIONS_FIELD_DESC = new org.apache.thrift.protocol.TField("versions", org.apache.thrift.protocol.TType.I32, (short)4);
  private static final org.apache.thrift.protocol.TField ROW_LIMIT_FIELD_DESC = new org.apache.thrift.protocol.TField("row_limit", org.apache.thrift.protocol.TType.I32, (short)5);
  private static final org.apache.thrift.protocol.TField START_TIME_FIELD_DESC = new org.apache.thrift.protocol.TField("start_time", org.apache.thrift.protocol.TType.I64, (short)6);
  private static final org.apache.thrift.protocol.TField END_TIME_FIELD_DESC = new org.apache.thrift.protocol.TField("end_time", org.apache.thrift.protocol.TType.I64, (short)7);
  private static final org.apache.thrift.protocol.TField COLUMNS_FIELD_DESC = new org.apache.thrift.protocol.TField("columns", org.apache.thrift.protocol.TType.LIST, (short)8);
  private static final org.apache.thrift.protocol.TField KEYS_ONLY_FIELD_DESC = new org.apache.thrift.protocol.TField("keys_only", org.apache.thrift.protocol.TType.BOOL, (short)9);
  private static final org.apache.thrift.protocol.TField CELL_LIMIT_FIELD_DESC = new org.apache.thrift.protocol.TField("cell_limit", org.apache.thrift.protocol.TType.I32, (short)14);
  private static final org.apache.thrift.protocol.TField CELL_LIMIT_PER_FAMILY_FIELD_DESC = new org.apache.thrift.protocol.TField("cell_limit_per_family", org.apache.thrift.protocol.TType.I32, (short)10);
  private static final org.apache.thrift.protocol.TField ROW_REGEXP_FIELD_DESC = new org.apache.thrift.protocol.TField("row_regexp", org.apache.thrift.protocol.TType.STRING, (short)11);
  private static final org.apache.thrift.protocol.TField VALUE_REGEXP_FIELD_DESC = new org.apache.thrift.protocol.TField("value_regexp", org.apache.thrift.protocol.TType.STRING, (short)12);
  private static final org.apache.thrift.protocol.TField SCAN_AND_FILTER_ROWS_FIELD_DESC = new org.apache.thrift.protocol.TField("scan_and_filter_rows", org.apache.thrift.protocol.TType.BOOL, (short)13);
  private static final org.apache.thrift.protocol.TField ROW_OFFSET_FIELD_DESC = new org.apache.thrift.protocol.TField("row_offset", org.apache.thrift.protocol.TType.I32, (short)15);
  private static final org.apache.thrift.protocol.TField CELL_OFFSET_FIELD_DESC = new org.apache.thrift.protocol.TField("cell_offset", org.apache.thrift.protocol.TType.I32, (short)16);
  private static final org.apache.thrift.protocol.TField COLUMN_PREDICATES_FIELD_DESC = new org.apache.thrift.protocol.TField("column_predicates", org.apache.thrift.protocol.TType.LIST, (short)17);
  private static final org.apache.thrift.protocol.TField DO_NOT_CACHE_FIELD_DESC = new org.apache.thrift.protocol.TField("do_not_cache", org.apache.thrift.protocol.TType.BOOL, (short)18);

  private static final Map<Class<? extends IScheme>, SchemeFactory> schemes = new HashMap<Class<? extends IScheme>, SchemeFactory>();
  static {
    schemes.put(StandardScheme.class, new ScanSpecStandardSchemeFactory());
    schemes.put(TupleScheme.class, new ScanSpecTupleSchemeFactory());
  }

  public List<RowInterval> row_intervals; // optional
  public List<CellInterval> cell_intervals; // optional
  public boolean return_deletes; // optional
  public int versions; // optional
  public int row_limit; // optional
  public long start_time; // optional
  public long end_time; // optional
  public List<String> columns; // optional
  public boolean keys_only; // optional
  public int cell_limit; // optional
  public int cell_limit_per_family; // optional
  public String row_regexp; // optional
  public String value_regexp; // optional
  public boolean scan_and_filter_rows; // optional
  public int row_offset; // optional
  public int cell_offset; // optional
  public List<ColumnPredicate> column_predicates; // optional
  public boolean do_not_cache; // optional

  /** The set of fields this struct contains, along with convenience methods for finding and manipulating them. */
  public enum _Fields implements org.apache.thrift.TFieldIdEnum {
    ROW_INTERVALS((short)1, "row_intervals"),
    CELL_INTERVALS((short)2, "cell_intervals"),
    RETURN_DELETES((short)3, "return_deletes"),
    VERSIONS((short)4, "versions"),
    ROW_LIMIT((short)5, "row_limit"),
    START_TIME((short)6, "start_time"),
    END_TIME((short)7, "end_time"),
    COLUMNS((short)8, "columns"),
    KEYS_ONLY((short)9, "keys_only"),
    CELL_LIMIT((short)14, "cell_limit"),
    CELL_LIMIT_PER_FAMILY((short)10, "cell_limit_per_family"),
    ROW_REGEXP((short)11, "row_regexp"),
    VALUE_REGEXP((short)12, "value_regexp"),
    SCAN_AND_FILTER_ROWS((short)13, "scan_and_filter_rows"),
    ROW_OFFSET((short)15, "row_offset"),
    CELL_OFFSET((short)16, "cell_offset"),
    COLUMN_PREDICATES((short)17, "column_predicates"),
    DO_NOT_CACHE((short)18, "do_not_cache");

    private static final Map<String, _Fields> byName = new HashMap<String, _Fields>();

    static {
      for (_Fields field : EnumSet.allOf(_Fields.class)) {
        byName.put(field.getFieldName(), field);
      }
    }

    /**
     * Find the _Fields constant that matches fieldId, or null if its not found.
     */
    public static _Fields findByThriftId(int fieldId) {
      switch(fieldId) {
        case 1: // ROW_INTERVALS
          return ROW_INTERVALS;
        case 2: // CELL_INTERVALS
          return CELL_INTERVALS;
        case 3: // RETURN_DELETES
          return RETURN_DELETES;
        case 4: // VERSIONS
          return VERSIONS;
        case 5: // ROW_LIMIT
          return ROW_LIMIT;
        case 6: // START_TIME
          return START_TIME;
        case 7: // END_TIME
          return END_TIME;
        case 8: // COLUMNS
          return COLUMNS;
        case 9: // KEYS_ONLY
          return KEYS_ONLY;
        case 14: // CELL_LIMIT
          return CELL_LIMIT;
        case 10: // CELL_LIMIT_PER_FAMILY
          return CELL_LIMIT_PER_FAMILY;
        case 11: // ROW_REGEXP
          return ROW_REGEXP;
        case 12: // VALUE_REGEXP
          return VALUE_REGEXP;
        case 13: // SCAN_AND_FILTER_ROWS
          return SCAN_AND_FILTER_ROWS;
        case 15: // ROW_OFFSET
          return ROW_OFFSET;
        case 16: // CELL_OFFSET
          return CELL_OFFSET;
        case 17: // COLUMN_PREDICATES
          return COLUMN_PREDICATES;
        case 18: // DO_NOT_CACHE
          return DO_NOT_CACHE;
        default:
          return null;
      }
    }

    /**
     * Find the _Fields constant that matches fieldId, throwing an exception
     * if it is not found.
     */
    public static _Fields findByThriftIdOrThrow(int fieldId) {
      _Fields fields = findByThriftId(fieldId);
      if (fields == null) throw new IllegalArgumentException("Field " + fieldId + " doesn't exist!");
      return fields;
    }

    /**
     * Find the _Fields constant that matches name, or null if its not found.
     */
    public static _Fields findByName(String name) {
      return byName.get(name);
    }

    private final short _thriftId;
    private final String _fieldName;

    _Fields(short thriftId, String fieldName) {
      _thriftId = thriftId;
      _fieldName = fieldName;
    }

    public short getThriftFieldId() {
      return _thriftId;
    }

    public String getFieldName() {
      return _fieldName;
    }
  }

  // isset id assignments
  private static final int __RETURN_DELETES_ISSET_ID = 0;
  private static final int __VERSIONS_ISSET_ID = 1;
  private static final int __ROW_LIMIT_ISSET_ID = 2;
  private static final int __START_TIME_ISSET_ID = 3;
  private static final int __END_TIME_ISSET_ID = 4;
  private static final int __KEYS_ONLY_ISSET_ID = 5;
  private static final int __CELL_LIMIT_ISSET_ID = 6;
  private static final int __CELL_LIMIT_PER_FAMILY_ISSET_ID = 7;
  private static final int __SCAN_AND_FILTER_ROWS_ISSET_ID = 8;
  private static final int __ROW_OFFSET_ISSET_ID = 9;
  private static final int __CELL_OFFSET_ISSET_ID = 10;
  private static final int __DO_NOT_CACHE_ISSET_ID = 11;
  private short __isset_bitfield = 0;
  private static final _Fields optionals[] = {_Fields.ROW_INTERVALS,_Fields.CELL_INTERVALS,_Fields.RETURN_DELETES,_Fields.VERSIONS,_Fields.ROW_LIMIT,_Fields.START_TIME,_Fields.END_TIME,_Fields.COLUMNS,_Fields.KEYS_ONLY,_Fields.CELL_LIMIT,_Fields.CELL_LIMIT_PER_FAMILY,_Fields.ROW_REGEXP,_Fields.VALUE_REGEXP,_Fields.SCAN_AND_FILTER_ROWS,_Fields.ROW_OFFSET,_Fields.CELL_OFFSET,_Fields.COLUMN_PREDICATES,_Fields.DO_NOT_CACHE};
  public static final Map<_Fields, org.apache.thrift.meta_data.FieldMetaData> metaDataMap;
  static {
    Map<_Fields, org.apache.thrift.meta_data.FieldMetaData> tmpMap = new EnumMap<_Fields, org.apache.thrift.meta_data.FieldMetaData>(_Fields.class);
    tmpMap.put(_Fields.ROW_INTERVALS, new org.apache.thrift.meta_data.FieldMetaData("row_intervals", org.apache.thrift.TFieldRequirementType.OPTIONAL, 
        new org.apache.thrift.meta_data.ListMetaData(org.apache.thrift.protocol.TType.LIST, 
            new org.apache.thrift.meta_data.StructMetaData(org.apache.thrift.protocol.TType.STRUCT, RowInterval.class))));
    tmpMap.put(_Fields.CELL_INTERVALS, new org.apache.thrift.meta_data.FieldMetaData("cell_intervals", org.apache.thrift.TFieldRequirementType.OPTIONAL, 
        new org.apache.thrift.meta_data.ListMetaData(org.apache.thrift.protocol.TType.LIST, 
            new org.apache.thrift.meta_data.StructMetaData(org.apache.thrift.protocol.TType.STRUCT, CellInterval.class))));
    tmpMap.put(_Fields.RETURN_DELETES, new org.apache.thrift.meta_data.FieldMetaData("return_deletes", org.apache.thrift.TFieldRequirementType.OPTIONAL, 
        new org.apache.thrift.meta_data.FieldValueMetaData(org.apache.thrift.protocol.TType.BOOL)));
    tmpMap.put(_Fields.VERSIONS, new org.apache.thrift.meta_data.FieldMetaData("versions", org.apache.thrift.TFieldRequirementType.OPTIONAL, 
        new org.apache.thrift.meta_data.FieldValueMetaData(org.apache.thrift.protocol.TType.I32)));
    tmpMap.put(_Fields.ROW_LIMIT, new org.apache.thrift.meta_data.FieldMetaData("row_limit", org.apache.thrift.TFieldRequirementType.OPTIONAL, 
        new org.apache.thrift.meta_data.FieldValueMetaData(org.apache.thrift.protocol.TType.I32)));
    tmpMap.put(_Fields.START_TIME, new org.apache.thrift.meta_data.FieldMetaData("start_time", org.apache.thrift.TFieldRequirementType.OPTIONAL, 
        new org.apache.thrift.meta_data.FieldValueMetaData(org.apache.thrift.protocol.TType.I64)));
    tmpMap.put(_Fields.END_TIME, new org.apache.thrift.meta_data.FieldMetaData("end_time", org.apache.thrift.TFieldRequirementType.OPTIONAL, 
        new org.apache.thrift.meta_data.FieldValueMetaData(org.apache.thrift.protocol.TType.I64)));
    tmpMap.put(_Fields.COLUMNS, new org.apache.thrift.meta_data.FieldMetaData("columns", org.apache.thrift.TFieldRequirementType.OPTIONAL, 
        new org.apache.thrift.meta_data.ListMetaData(org.apache.thrift.protocol.TType.LIST, 
            new org.apache.thrift.meta_data.FieldValueMetaData(org.apache.thrift.protocol.TType.STRING))));
    tmpMap.put(_Fields.KEYS_ONLY, new org.apache.thrift.meta_data.FieldMetaData("keys_only", org.apache.thrift.TFieldRequirementType.OPTIONAL, 
        new org.apache.thrift.meta_data.FieldValueMetaData(org.apache.thrift.protocol.TType.BOOL)));
    tmpMap.put(_Fields.CELL_LIMIT, new org.apache.thrift.meta_data.FieldMetaData("cell_limit", org.apache.thrift.TFieldRequirementType.OPTIONAL, 
        new org.apache.thrift.meta_data.FieldValueMetaData(org.apache.thrift.protocol.TType.I32)));
    tmpMap.put(_Fields.CELL_LIMIT_PER_FAMILY, new org.apache.thrift.meta_data.FieldMetaData("cell_limit_per_family", org.apache.thrift.TFieldRequirementType.OPTIONAL, 
        new org.apache.thrift.meta_data.FieldValueMetaData(org.apache.thrift.protocol.TType.I32)));
    tmpMap.put(_Fields.ROW_REGEXP, new org.apache.thrift.meta_data.FieldMetaData("row_regexp", org.apache.thrift.TFieldRequirementType.OPTIONAL, 
        new org.apache.thrift.meta_data.FieldValueMetaData(org.apache.thrift.protocol.TType.STRING)));
    tmpMap.put(_Fields.VALUE_REGEXP, new org.apache.thrift.meta_data.FieldMetaData("value_regexp", org.apache.thrift.TFieldRequirementType.OPTIONAL, 
        new org.apache.thrift.meta_data.FieldValueMetaData(org.apache.thrift.protocol.TType.STRING)));
    tmpMap.put(_Fields.SCAN_AND_FILTER_ROWS, new org.apache.thrift.meta_data.FieldMetaData("scan_and_filter_rows", org.apache.thrift.TFieldRequirementType.OPTIONAL, 
        new org.apache.thrift.meta_data.FieldValueMetaData(org.apache.thrift.protocol.TType.BOOL)));
    tmpMap.put(_Fields.ROW_OFFSET, new org.apache.thrift.meta_data.FieldMetaData("row_offset", org.apache.thrift.TFieldRequirementType.OPTIONAL, 
        new org.apache.thrift.meta_data.FieldValueMetaData(org.apache.thrift.protocol.TType.I32)));
    tmpMap.put(_Fields.CELL_OFFSET, new org.apache.thrift.meta_data.FieldMetaData("cell_offset", org.apache.thrift.TFieldRequirementType.OPTIONAL, 
        new org.apache.thrift.meta_data.FieldValueMetaData(org.apache.thrift.protocol.TType.I32)));
    tmpMap.put(_Fields.COLUMN_PREDICATES, new org.apache.thrift.meta_data.FieldMetaData("column_predicates", org.apache.thrift.TFieldRequirementType.OPTIONAL, 
        new org.apache.thrift.meta_data.ListMetaData(org.apache.thrift.protocol.TType.LIST, 
            new org.apache.thrift.meta_data.StructMetaData(org.apache.thrift.protocol.TType.STRUCT, ColumnPredicate.class))));
    tmpMap.put(_Fields.DO_NOT_CACHE, new org.apache.thrift.meta_data.FieldMetaData("do_not_cache", org.apache.thrift.TFieldRequirementType.OPTIONAL, 
        new org.apache.thrift.meta_data.FieldValueMetaData(org.apache.thrift.protocol.TType.BOOL)));
    metaDataMap = Collections.unmodifiableMap(tmpMap);
    org.apache.thrift.meta_data.FieldMetaData.addStructMetaDataMap(ScanSpec.class, metaDataMap);
  }

  public ScanSpec() {
    this.return_deletes = false;

    this.versions = 0;

    this.row_limit = 0;

    this.keys_only = false;

    this.cell_limit = 0;

    this.cell_limit_per_family = 0;

    this.scan_and_filter_rows = false;

    this.row_offset = 0;

    this.cell_offset = 0;

    this.do_not_cache = false;

  }

  /**
   * Performs a deep copy on <i>other</i>.
   */
  public ScanSpec(ScanSpec other) {
    __isset_bitfield = other.__isset_bitfield;
    if (other.isSetRow_intervals()) {
      List<RowInterval> __this__row_intervals = new ArrayList<RowInterval>(other.row_intervals.size());
      for (RowInterval other_element : other.row_intervals) {
        __this__row_intervals.add(new RowInterval(other_element));
      }
      this.row_intervals = __this__row_intervals;
    }
    if (other.isSetCell_intervals()) {
      List<CellInterval> __this__cell_intervals = new ArrayList<CellInterval>(other.cell_intervals.size());
      for (CellInterval other_element : other.cell_intervals) {
        __this__cell_intervals.add(new CellInterval(other_element));
      }
      this.cell_intervals = __this__cell_intervals;
    }
    this.return_deletes = other.return_deletes;
    this.versions = other.versions;
    this.row_limit = other.row_limit;
    this.start_time = other.start_time;
    this.end_time = other.end_time;
    if (other.isSetColumns()) {
      List<String> __this__columns = new ArrayList<String>(other.columns);
      this.columns = __this__columns;
    }
    this.keys_only = other.keys_only;
    this.cell_limit = other.cell_limit;
    this.cell_limit_per_family = other.cell_limit_per_family;
    if (other.isSetRow_regexp()) {
      this.row_regexp = other.row_regexp;
    }
    if (other.isSetValue_regexp()) {
      this.value_regexp = other.value_regexp;
    }
    this.scan_and_filter_rows = other.scan_and_filter_rows;
    this.row_offset = other.row_offset;
    this.cell_offset = other.cell_offset;
    if (other.isSetColumn_predicates()) {
      List<ColumnPredicate> __this__column_predicates = new ArrayList<ColumnPredicate>(other.column_predicates.size());
      for (ColumnPredicate other_element : other.column_predicates) {
        __this__column_predicates.add(new ColumnPredicate(other_element));
      }
      this.column_predicates = __this__column_predicates;
    }
    this.do_not_cache = other.do_not_cache;
  }

  public ScanSpec deepCopy() {
    return new ScanSpec(this);
  }

  @Override
  public void clear() {
    this.row_intervals = null;
    this.cell_intervals = null;
    this.return_deletes = false;

    this.versions = 0;

    this.row_limit = 0;

    setStart_timeIsSet(false);
    this.start_time = 0;
    setEnd_timeIsSet(false);
    this.end_time = 0;
    this.columns = null;
    this.keys_only = false;

    this.cell_limit = 0;

    this.cell_limit_per_family = 0;

    this.row_regexp = null;
    this.value_regexp = null;
    this.scan_and_filter_rows = false;

    this.row_offset = 0;

    this.cell_offset = 0;

    this.column_predicates = null;
    this.do_not_cache = false;

  }

  public int getRow_intervalsSize() {
    return (this.row_intervals == null) ? 0 : this.row_intervals.size();
  }

  public java.util.Iterator<RowInterval> getRow_intervalsIterator() {
    return (this.row_intervals == null) ? null : this.row_intervals.iterator();
  }

  public void addToRow_intervals(RowInterval elem) {
    if (this.row_intervals == null) {
      this.row_intervals = new ArrayList<RowInterval>();
    }
    this.row_intervals.add(elem);
  }

  public List<RowInterval> getRow_intervals() {
    return this.row_intervals;
  }

  public ScanSpec setRow_intervals(List<RowInterval> row_intervals) {
    this.row_intervals = row_intervals;
    return this;
  }

  public void unsetRow_intervals() {
    this.row_intervals = null;
  }

  /** Returns true if field row_intervals is set (has been assigned a value) and false otherwise */
  public boolean isSetRow_intervals() {
    return this.row_intervals != null;
  }

  public void setRow_intervalsIsSet(boolean value) {
    if (!value) {
      this.row_intervals = null;
    }
  }

  public int getCell_intervalsSize() {
    return (this.cell_intervals == null) ? 0 : this.cell_intervals.size();
  }

  public java.util.Iterator<CellInterval> getCell_intervalsIterator() {
    return (this.cell_intervals == null) ? null : this.cell_intervals.iterator();
  }

  public void addToCell_intervals(CellInterval elem) {
    if (this.cell_intervals == null) {
      this.cell_intervals = new ArrayList<CellInterval>();
    }
    this.cell_intervals.add(elem);
  }

  public List<CellInterval> getCell_intervals() {
    return this.cell_intervals;
  }

  public ScanSpec setCell_intervals(List<CellInterval> cell_intervals) {
    this.cell_intervals = cell_intervals;
    return this;
  }

  public void unsetCell_intervals() {
    this.cell_intervals = null;
  }

  /** Returns true if field cell_intervals is set (has been assigned a value) and false otherwise */
  public boolean isSetCell_intervals() {
    return this.cell_intervals != null;
  }

  public void setCell_intervalsIsSet(boolean value) {
    if (!value) {
      this.cell_intervals = null;
    }
  }

  public boolean isReturn_deletes() {
    return this.return_deletes;
  }

  public ScanSpec setReturn_deletes(boolean return_deletes) {
    this.return_deletes = return_deletes;
    setReturn_deletesIsSet(true);
    return this;
  }

  public void unsetReturn_deletes() {
    __isset_bitfield = EncodingUtils.clearBit(__isset_bitfield, __RETURN_DELETES_ISSET_ID);
  }

  /** Returns true if field return_deletes is set (has been assigned a value) and false otherwise */
  public boolean isSetReturn_deletes() {
    return EncodingUtils.testBit(__isset_bitfield, __RETURN_DELETES_ISSET_ID);
  }

  public void setReturn_deletesIsSet(boolean value) {
    __isset_bitfield = EncodingUtils.setBit(__isset_bitfield, __RETURN_DELETES_ISSET_ID, value);
  }

  public int getVersions() {
    return this.versions;
  }

  public ScanSpec setVersions(int versions) {
    this.versions = versions;
    setVersionsIsSet(true);
    return this;
  }

  public void unsetVersions() {
    __isset_bitfield = EncodingUtils.clearBit(__isset_bitfield, __VERSIONS_ISSET_ID);
  }

  /** Returns true if field versions is set (has been assigned a value) and false otherwise */
  public boolean isSetVersions() {
    return EncodingUtils.testBit(__isset_bitfield, __VERSIONS_ISSET_ID);
  }

  public void setVersionsIsSet(boolean value) {
    __isset_bitfield = EncodingUtils.setBit(__isset_bitfield, __VERSIONS_ISSET_ID, value);
  }

  public int getRow_limit() {
    return this.row_limit;
  }

  public ScanSpec setRow_limit(int row_limit) {
    this.row_limit = row_limit;
    setRow_limitIsSet(true);
    return this;
  }

  public void unsetRow_limit() {
    __isset_bitfield = EncodingUtils.clearBit(__isset_bitfield, __ROW_LIMIT_ISSET_ID);
  }

  /** Returns true if field row_limit is set (has been assigned a value) and false otherwise */
  public boolean isSetRow_limit() {
    return EncodingUtils.testBit(__isset_bitfield, __ROW_LIMIT_ISSET_ID);
  }

  public void setRow_limitIsSet(boolean value) {
    __isset_bitfield = EncodingUtils.setBit(__isset_bitfield, __ROW_LIMIT_ISSET_ID, value);
  }

  public long getStart_time() {
    return this.start_time;
  }

  public ScanSpec setStart_time(long start_time) {
    this.start_time = start_time;
    setStart_timeIsSet(true);
    return this;
  }

  public void unsetStart_time() {
    __isset_bitfield = EncodingUtils.clearBit(__isset_bitfield, __START_TIME_ISSET_ID);
  }

  /** Returns true if field start_time is set (has been assigned a value) and false otherwise */
  public boolean isSetStart_time() {
    return EncodingUtils.testBit(__isset_bitfield, __START_TIME_ISSET_ID);
  }

  public void setStart_timeIsSet(boolean value) {
    __isset_bitfield = EncodingUtils.setBit(__isset_bitfield, __START_TIME_ISSET_ID, value);
  }

  public long getEnd_time() {
    return this.end_time;
  }

  public ScanSpec setEnd_time(long end_time) {
    this.end_time = end_time;
    setEnd_timeIsSet(true);
    return this;
  }

  public void unsetEnd_time() {
    __isset_bitfield = EncodingUtils.clearBit(__isset_bitfield, __END_TIME_ISSET_ID);
  }

  /** Returns true if field end_time is set (has been assigned a value) and false otherwise */
  public boolean isSetEnd_time() {
    return EncodingUtils.testBit(__isset_bitfield, __END_TIME_ISSET_ID);
  }

  public void setEnd_timeIsSet(boolean value) {
    __isset_bitfield = EncodingUtils.setBit(__isset_bitfield, __END_TIME_ISSET_ID, value);
  }

  public int getColumnsSize() {
    return (this.columns == null) ? 0 : this.columns.size();
  }

  public java.util.Iterator<String> getColumnsIterator() {
    return (this.columns == null) ? null : this.columns.iterator();
  }

  public void addToColumns(String elem) {
    if (this.columns == null) {
      this.columns = new ArrayList<String>();
    }
    this.columns.add(elem);
  }

  public List<String> getColumns() {
    return this.columns;
  }

  public ScanSpec setColumns(List<String> columns) {
    this.columns = columns;
    return this;
  }

  public void unsetColumns() {
    this.columns = null;
  }

  /** Returns true if field columns is set (has been assigned a value) and false otherwise */
  public boolean isSetColumns() {
    return this.columns != null;
  }

  public void setColumnsIsSet(boolean value) {
    if (!value) {
      this.columns = null;
    }
  }

  public boolean isKeys_only() {
    return this.keys_only;
  }

  public ScanSpec setKeys_only(boolean keys_only) {
    this.keys_only = keys_only;
    setKeys_onlyIsSet(true);
    return this;
  }

  public void unsetKeys_only() {
    __isset_bitfield = EncodingUtils.clearBit(__isset_bitfield, __KEYS_ONLY_ISSET_ID);
  }

  /** Returns true if field keys_only is set (has been assigned a value) and false otherwise */
  public boolean isSetKeys_only() {
    return EncodingUtils.testBit(__isset_bitfield, __KEYS_ONLY_ISSET_ID);
  }

  public void setKeys_onlyIsSet(boolean value) {
    __isset_bitfield = EncodingUtils.setBit(__isset_bitfield, __KEYS_ONLY_ISSET_ID, value);
  }

  public int getCell_limit() {
    return this.cell_limit;
  }

  public ScanSpec setCell_limit(int cell_limit) {
    this.cell_limit = cell_limit;
    setCell_limitIsSet(true);
    return this;
  }

  public void unsetCell_limit() {
    __isset_bitfield = EncodingUtils.clearBit(__isset_bitfield, __CELL_LIMIT_ISSET_ID);
  }

  /** Returns true if field cell_limit is set (has been assigned a value) and false otherwise */
  public boolean isSetCell_limit() {
    return EncodingUtils.testBit(__isset_bitfield, __CELL_LIMIT_ISSET_ID);
  }

  public void setCell_limitIsSet(boolean value) {
    __isset_bitfield = EncodingUtils.setBit(__isset_bitfield, __CELL_LIMIT_ISSET_ID, value);
  }

  public int getCell_limit_per_family() {
    return this.cell_limit_per_family;
  }

  public ScanSpec setCell_limit_per_family(int cell_limit_per_family) {
    this.cell_limit_per_family = cell_limit_per_family;
    setCell_limit_per_familyIsSet(true);
    return this;
  }

  public void unsetCell_limit_per_family() {
    __isset_bitfield = EncodingUtils.clearBit(__isset_bitfield, __CELL_LIMIT_PER_FAMILY_ISSET_ID);
  }

  /** Returns true if field cell_limit_per_family is set (has been assigned a value) and false otherwise */
  public boolean isSetCell_limit_per_family() {
    return EncodingUtils.testBit(__isset_bitfield, __CELL_LIMIT_PER_FAMILY_ISSET_ID);
  }

  public void setCell_limit_per_familyIsSet(boolean value) {
    __isset_bitfield = EncodingUtils.setBit(__isset_bitfield, __CELL_LIMIT_PER_FAMILY_ISSET_ID, value);
  }

  public String getRow_regexp() {
    return this.row_regexp;
  }

  public ScanSpec setRow_regexp(String row_regexp) {
    this.row_regexp = row_regexp;
    return this;
  }

  public void unsetRow_regexp() {
    this.row_regexp = null;
  }

  /** Returns true if field row_regexp is set (has been assigned a value) and false otherwise */
  public boolean isSetRow_regexp() {
    return this.row_regexp != null;
  }

  public void setRow_regexpIsSet(boolean value) {
    if (!value) {
      this.row_regexp = null;
    }
  }

  public String getValue_regexp() {
    return this.value_regexp;
  }

  public ScanSpec setValue_regexp(String value_regexp) {
    this.value_regexp = value_regexp;
    return this;
  }

  public void unsetValue_regexp() {
    this.value_regexp = null;
  }

  /** Returns true if field value_regexp is set (has been assigned a value) and false otherwise */
  public boolean isSetValue_regexp() {
    return this.value_regexp != null;
  }

  public void setValue_regexpIsSet(boolean value) {
    if (!value) {
      this.value_regexp = null;
    }
  }

  public boolean isScan_and_filter_rows() {
    return this.scan_and_filter_rows;
  }

  public ScanSpec setScan_and_filter_rows(boolean scan_and_filter_rows) {
    this.scan_and_filter_rows = scan_and_filter_rows;
    setScan_and_filter_rowsIsSet(true);
    return this;
  }

  public void unsetScan_and_filter_rows() {
    __isset_bitfield = EncodingUtils.clearBit(__isset_bitfield, __SCAN_AND_FILTER_ROWS_ISSET_ID);
  }

  /** Returns true if field scan_and_filter_rows is set (has been assigned a value) and false otherwise */
  public boolean isSetScan_and_filter_rows() {
    return EncodingUtils.testBit(__isset_bitfield, __SCAN_AND_FILTER_ROWS_ISSET_ID);
  }

  public void setScan_and_filter_rowsIsSet(boolean value) {
    __isset_bitfield = EncodingUtils.setBit(__isset_bitfield, __SCAN_AND_FILTER_ROWS_ISSET_ID, value);
  }

  public int getRow_offset() {
    return this.row_offset;
  }

  public ScanSpec setRow_offset(int row_offset) {
    this.row_offset = row_offset;
    setRow_offsetIsSet(true);
    return this;
  }

  public void unsetRow_offset() {
    __isset_bitfield = EncodingUtils.clearBit(__isset_bitfield, __ROW_OFFSET_ISSET_ID);
  }

  /** Returns true if field row_offset is set (has been assigned a value) and false otherwise */
  public boolean isSetRow_offset() {
    return EncodingUtils.testBit(__isset_bitfield, __ROW_OFFSET_ISSET_ID);
  }

  public void setRow_offsetIsSet(boolean value) {
    __isset_bitfield = EncodingUtils.setBit(__isset_bitfield, __ROW_OFFSET_ISSET_ID, value);
  }

  public int getCell_offset() {
    return this.cell_offset;
  }

  public ScanSpec setCell_offset(int cell_offset) {
    this.cell_offset = cell_offset;
    setCell_offsetIsSet(true);
    return this;
  }

  public void unsetCell_offset() {
    __isset_bitfield = EncodingUtils.clearBit(__isset_bitfield, __CELL_OFFSET_ISSET_ID);
  }

  /** Returns true if field cell_offset is set (has been assigned a value) and false otherwise */
  public boolean isSetCell_offset() {
    return EncodingUtils.testBit(__isset_bitfield, __CELL_OFFSET_ISSET_ID);
  }

  public void setCell_offsetIsSet(boolean value) {
    __isset_bitfield = EncodingUtils.setBit(__isset_bitfield, __CELL_OFFSET_ISSET_ID, value);
  }

  public int getColumn_predicatesSize() {
    return (this.column_predicates == null) ? 0 : this.column_predicates.size();
  }

  public java.util.Iterator<ColumnPredicate> getColumn_predicatesIterator() {
    return (this.column_predicates == null) ? null : this.column_predicates.iterator();
  }

  public void addToColumn_predicates(ColumnPredicate elem) {
    if (this.column_predicates == null) {
      this.column_predicates = new ArrayList<ColumnPredicate>();
    }
    this.column_predicates.add(elem);
  }

  public List<ColumnPredicate> getColumn_predicates() {
    return this.column_predicates;
  }

  public ScanSpec setColumn_predicates(List<ColumnPredicate> column_predicates) {
    this.column_predicates = column_predicates;
    return this;
  }

  public void unsetColumn_predicates() {
    this.column_predicates = null;
  }

  /** Returns true if field column_predicates is set (has been assigned a value) and false otherwise */
  public boolean isSetColumn_predicates() {
    return this.column_predicates != null;
  }

  public void setColumn_predicatesIsSet(boolean value) {
    if (!value) {
      this.column_predicates = null;
    }
  }

  public boolean isDo_not_cache() {
    return this.do_not_cache;
  }

  public ScanSpec setDo_not_cache(boolean do_not_cache) {
    this.do_not_cache = do_not_cache;
    setDo_not_cacheIsSet(true);
    return this;
  }

  public void unsetDo_not_cache() {
    __isset_bitfield = EncodingUtils.clearBit(__isset_bitfield, __DO_NOT_CACHE_ISSET_ID);
  }

  /** Returns true if field do_not_cache is set (has been assigned a value) and false otherwise */
  public boolean isSetDo_not_cache() {
    return EncodingUtils.testBit(__isset_bitfield, __DO_NOT_CACHE_ISSET_ID);
  }

  public void setDo_not_cacheIsSet(boolean value) {
    __isset_bitfield = EncodingUtils.setBit(__isset_bitfield, __DO_NOT_CACHE_ISSET_ID, value);
  }

  public void setFieldValue(_Fields field, Object value) {
    switch (field) {
    case ROW_INTERVALS:
      if (value == null) {
        unsetRow_intervals();
      } else {
        setRow_intervals((List<RowInterval>)value);
      }
      break;

    case CELL_INTERVALS:
      if (value == null) {
        unsetCell_intervals();
      } else {
        setCell_intervals((List<CellInterval>)value);
      }
      break;

    case RETURN_DELETES:
      if (value == null) {
        unsetReturn_deletes();
      } else {
        setReturn_deletes((Boolean)value);
      }
      break;

    case VERSIONS:
      if (value == null) {
        unsetVersions();
      } else {
        setVersions((Integer)value);
      }
      break;

    case ROW_LIMIT:
      if (value == null) {
        unsetRow_limit();
      } else {
        setRow_limit((Integer)value);
      }
      break;

    case START_TIME:
      if (value == null) {
        unsetStart_time();
      } else {
        setStart_time((Long)value);
      }
      break;

    case END_TIME:
      if (value == null) {
        unsetEnd_time();
      } else {
        setEnd_time((Long)value);
      }
      break;

    case COLUMNS:
      if (value == null) {
        unsetColumns();
      } else {
        setColumns((List<String>)value);
      }
      break;

    case KEYS_ONLY:
      if (value == null) {
        unsetKeys_only();
      } else {
        setKeys_only((Boolean)value);
      }
      break;

    case CELL_LIMIT:
      if (value == null) {
        unsetCell_limit();
      } else {
        setCell_limit((Integer)value);
      }
      break;

    case CELL_LIMIT_PER_FAMILY:
      if (value == null) {
        unsetCell_limit_per_family();
      } else {
        setCell_limit_per_family((Integer)value);
      }
      break;

    case ROW_REGEXP:
      if (value == null) {
        unsetRow_regexp();
      } else {
        setRow_regexp((String)value);
      }
      break;

    case VALUE_REGEXP:
      if (value == null) {
        unsetValue_regexp();
      } else {
        setValue_regexp((String)value);
      }
      break;

    case SCAN_AND_FILTER_ROWS:
      if (value == null) {
        unsetScan_and_filter_rows();
      } else {
        setScan_and_filter_rows((Boolean)value);
      }
      break;

    case ROW_OFFSET:
      if (value == null) {
        unsetRow_offset();
      } else {
        setRow_offset((Integer)value);
      }
      break;

    case CELL_OFFSET:
      if (value == null) {
        unsetCell_offset();
      } else {
        setCell_offset((Integer)value);
      }
      break;

    case COLUMN_PREDICATES:
      if (value == null) {
        unsetColumn_predicates();
      } else {
        setColumn_predicates((List<ColumnPredicate>)value);
      }
      break;

    case DO_NOT_CACHE:
      if (value == null) {
        unsetDo_not_cache();
      } else {
        setDo_not_cache((Boolean)value);
      }
      break;

    }
  }

  public Object getFieldValue(_Fields field) {
    switch (field) {
    case ROW_INTERVALS:
      return getRow_intervals();

    case CELL_INTERVALS:
      return getCell_intervals();

    case RETURN_DELETES:
      return Boolean.valueOf(isReturn_deletes());

    case VERSIONS:
      return Integer.valueOf(getVersions());

    case ROW_LIMIT:
      return Integer.valueOf(getRow_limit());

    case START_TIME:
      return Long.valueOf(getStart_time());

    case END_TIME:
      return Long.valueOf(getEnd_time());

    case COLUMNS:
      return getColumns();

    case KEYS_ONLY:
      return Boolean.valueOf(isKeys_only());

    case CELL_LIMIT:
      return Integer.valueOf(getCell_limit());

    case CELL_LIMIT_PER_FAMILY:
      return Integer.valueOf(getCell_limit_per_family());

    case ROW_REGEXP:
      return getRow_regexp();

    case VALUE_REGEXP:
      return getValue_regexp();

    case SCAN_AND_FILTER_ROWS:
      return Boolean.valueOf(isScan_and_filter_rows());

    case ROW_OFFSET:
      return Integer.valueOf(getRow_offset());

    case CELL_OFFSET:
      return Integer.valueOf(getCell_offset());

    case COLUMN_PREDICATES:
      return getColumn_predicates();

    case DO_NOT_CACHE:
      return Boolean.valueOf(isDo_not_cache());

    }
    throw new IllegalStateException();
  }

  /** Returns true if field corresponding to fieldID is set (has been assigned a value) and false otherwise */
  public boolean isSet(_Fields field) {
    if (field == null) {
      throw new IllegalArgumentException();
    }

    switch (field) {
    case ROW_INTERVALS:
      return isSetRow_intervals();
    case CELL_INTERVALS:
      return isSetCell_intervals();
    case RETURN_DELETES:
      return isSetReturn_deletes();
    case VERSIONS:
      return isSetVersions();
    case ROW_LIMIT:
      return isSetRow_limit();
    case START_TIME:
      return isSetStart_time();
    case END_TIME:
      return isSetEnd_time();
    case COLUMNS:
      return isSetColumns();
    case KEYS_ONLY:
      return isSetKeys_only();
    case CELL_LIMIT:
      return isSetCell_limit();
    case CELL_LIMIT_PER_FAMILY:
      return isSetCell_limit_per_family();
    case ROW_REGEXP:
      return isSetRow_regexp();
    case VALUE_REGEXP:
      return isSetValue_regexp();
    case SCAN_AND_FILTER_ROWS:
      return isSetScan_and_filter_rows();
    case ROW_OFFSET:
      return isSetRow_offset();
    case CELL_OFFSET:
      return isSetCell_offset();
    case COLUMN_PREDICATES:
      return isSetColumn_predicates();
    case DO_NOT_CACHE:
      return isSetDo_not_cache();
    }
    throw new IllegalStateException();
  }

  @Override
  public boolean equals(Object that) {
    if (that == null)
      return false;
    if (that instanceof ScanSpec)
      return this.equals((ScanSpec)that);
    return false;
  }

  public boolean equals(ScanSpec that) {
    if (that == null)
      return false;

    boolean this_present_row_intervals = true && this.isSetRow_intervals();
    boolean that_present_row_intervals = true && that.isSetRow_intervals();
    if (this_present_row_intervals || that_present_row_intervals) {
      if (!(this_present_row_intervals && that_present_row_intervals))
        return false;
      if (!this.row_intervals.equals(that.row_intervals))
        return false;
    }

    boolean this_present_cell_intervals = true && this.isSetCell_intervals();
    boolean that_present_cell_intervals = true && that.isSetCell_intervals();
    if (this_present_cell_intervals || that_present_cell_intervals) {
      if (!(this_present_cell_intervals && that_present_cell_intervals))
        return false;
      if (!this.cell_intervals.equals(that.cell_intervals))
        return false;
    }

    boolean this_present_return_deletes = true && this.isSetReturn_deletes();
    boolean that_present_return_deletes = true && that.isSetReturn_deletes();
    if (this_present_return_deletes || that_present_return_deletes) {
      if (!(this_present_return_deletes && that_present_return_deletes))
        return false;
      if (this.return_deletes != that.return_deletes)
        return false;
    }

    boolean this_present_versions = true && this.isSetVersions();
    boolean that_present_versions = true && that.isSetVersions();
    if (this_present_versions || that_present_versions) {
      if (!(this_present_versions && that_present_versions))
        return false;
      if (this.versions != that.versions)
        return false;
    }

    boolean this_present_row_limit = true && this.isSetRow_limit();
    boolean that_present_row_limit = true && that.isSetRow_limit();
    if (this_present_row_limit || that_present_row_limit) {
      if (!(this_present_row_limit && that_present_row_limit))
        return false;
      if (this.row_limit != that.row_limit)
        return false;
    }

    boolean this_present_start_time = true && this.isSetStart_time();
    boolean that_present_start_time = true && that.isSetStart_time();
    if (this_present_start_time || that_present_start_time) {
      if (!(this_present_start_time && that_present_start_time))
        return false;
      if (this.start_time != that.start_time)
        return false;
    }

    boolean this_present_end_time = true && this.isSetEnd_time();
    boolean that_present_end_time = true && that.isSetEnd_time();
    if (this_present_end_time || that_present_end_time) {
      if (!(this_present_end_time && that_present_end_time))
        return false;
      if (this.end_time != that.end_time)
        return false;
    }

    boolean this_present_columns = true && this.isSetColumns();
    boolean that_present_columns = true && that.isSetColumns();
    if (this_present_columns || that_present_columns) {
      if (!(this_present_columns && that_present_columns))
        return false;
      if (!this.columns.equals(that.columns))
        return false;
    }

    boolean this_present_keys_only = true && this.isSetKeys_only();
    boolean that_present_keys_only = true && that.isSetKeys_only();
    if (this_present_keys_only || that_present_keys_only) {
      if (!(this_present_keys_only && that_present_keys_only))
        return false;
      if (this.keys_only != that.keys_only)
        return false;
    }

    boolean this_present_cell_limit = true && this.isSetCell_limit();
    boolean that_present_cell_limit = true && that.isSetCell_limit();
    if (this_present_cell_limit || that_present_cell_limit) {
      if (!(this_present_cell_limit && that_present_cell_limit))
        return false;
      if (this.cell_limit != that.cell_limit)
        return false;
    }

    boolean this_present_cell_limit_per_family = true && this.isSetCell_limit_per_family();
    boolean that_present_cell_limit_per_family = true && that.isSetCell_limit_per_family();
    if (this_present_cell_limit_per_family || that_present_cell_limit_per_family) {
      if (!(this_present_cell_limit_per_family && that_present_cell_limit_per_family))
        return false;
      if (this.cell_limit_per_family != that.cell_limit_per_family)
        return false;
    }

    boolean this_present_row_regexp = true && this.isSetRow_regexp();
    boolean that_present_row_regexp = true && that.isSetRow_regexp();
    if (this_present_row_regexp || that_present_row_regexp) {
      if (!(this_present_row_regexp && that_present_row_regexp))
        return false;
      if (!this.row_regexp.equals(that.row_regexp))
        return false;
    }

    boolean this_present_value_regexp = true && this.isSetValue_regexp();
    boolean that_present_value_regexp = true && that.isSetValue_regexp();
    if (this_present_value_regexp || that_present_value_regexp) {
      if (!(this_present_value_regexp && that_present_value_regexp))
        return false;
      if (!this.value_regexp.equals(that.value_regexp))
        return false;
    }

    boolean this_present_scan_and_filter_rows = true && this.isSetScan_and_filter_rows();
    boolean that_present_scan_and_filter_rows = true && that.isSetScan_and_filter_rows();
    if (this_present_scan_and_filter_rows || that_present_scan_and_filter_rows) {
      if (!(this_present_scan_and_filter_rows && that_present_scan_and_filter_rows))
        return false;
      if (this.scan_and_filter_rows != that.scan_and_filter_rows)
        return false;
    }

    boolean this_present_row_offset = true && this.isSetRow_offset();
    boolean that_present_row_offset = true && that.isSetRow_offset();
    if (this_present_row_offset || that_present_row_offset) {
      if (!(this_present_row_offset && that_present_row_offset))
        return false;
      if (this.row_offset != that.row_offset)
        return false;
    }

    boolean this_present_cell_offset = true && this.isSetCell_offset();
    boolean that_present_cell_offset = true && that.isSetCell_offset();
    if (this_present_cell_offset || that_present_cell_offset) {
      if (!(this_present_cell_offset && that_present_cell_offset))
        return false;
      if (this.cell_offset != that.cell_offset)
        return false;
    }

    boolean this_present_column_predicates = true && this.isSetColumn_predicates();
    boolean that_present_column_predicates = true && that.isSetColumn_predicates();
    if (this_present_column_predicates || that_present_column_predicates) {
      if (!(this_present_column_predicates && that_present_column_predicates))
        return false;
      if (!this.column_predicates.equals(that.column_predicates))
        return false;
    }

    boolean this_present_do_not_cache = true && this.isSetDo_not_cache();
    boolean that_present_do_not_cache = true && that.isSetDo_not_cache();
    if (this_present_do_not_cache || that_present_do_not_cache) {
      if (!(this_present_do_not_cache && that_present_do_not_cache))
        return false;
      if (this.do_not_cache != that.do_not_cache)
        return false;
    }

    return true;
  }

  @Override
  public int hashCode() {
    List<Object> list = new ArrayList<Object>();

    boolean present_row_intervals = true && (isSetRow_intervals());
    list.add(present_row_intervals);
    if (present_row_intervals)
      list.add(row_intervals);

    boolean present_cell_intervals = true && (isSetCell_intervals());
    list.add(present_cell_intervals);
    if (present_cell_intervals)
      list.add(cell_intervals);

    boolean present_return_deletes = true && (isSetReturn_deletes());
    list.add(present_return_deletes);
    if (present_return_deletes)
      list.add(return_deletes);

    boolean present_versions = true && (isSetVersions());
    list.add(present_versions);
    if (present_versions)
      list.add(versions);

    boolean present_row_limit = true && (isSetRow_limit());
    list.add(present_row_limit);
    if (present_row_limit)
      list.add(row_limit);

    boolean present_start_time = true && (isSetStart_time());
    list.add(present_start_time);
    if (present_start_time)
      list.add(start_time);

    boolean present_end_time = true && (isSetEnd_time());
    list.add(present_end_time);
    if (present_end_time)
      list.add(end_time);

    boolean present_columns = true && (isSetColumns());
    list.add(present_columns);
    if (present_columns)
      list.add(columns);

    boolean present_keys_only = true && (isSetKeys_only());
    list.add(present_keys_only);
    if (present_keys_only)
      list.add(keys_only);

    boolean present_cell_limit = true && (isSetCell_limit());
    list.add(present_cell_limit);
    if (present_cell_limit)
      list.add(cell_limit);

    boolean present_cell_limit_per_family = true && (isSetCell_limit_per_family());
    list.add(present_cell_limit_per_family);
    if (present_cell_limit_per_family)
      list.add(cell_limit_per_family);

    boolean present_row_regexp = true && (isSetRow_regexp());
    list.add(present_row_regexp);
    if (present_row_regexp)
      list.add(row_regexp);

    boolean present_value_regexp = true && (isSetValue_regexp());
    list.add(present_value_regexp);
    if (present_value_regexp)
      list.add(value_regexp);

    boolean present_scan_and_filter_rows = true && (isSetScan_and_filter_rows());
    list.add(present_scan_and_filter_rows);
    if (present_scan_and_filter_rows)
      list.add(scan_and_filter_rows);

    boolean present_row_offset = true && (isSetRow_offset());
    list.add(present_row_offset);
    if (present_row_offset)
      list.add(row_offset);

    boolean present_cell_offset = true && (isSetCell_offset());
    list.add(present_cell_offset);
    if (present_cell_offset)
      list.add(cell_offset);

    boolean present_column_predicates = true && (isSetColumn_predicates());
    list.add(present_column_predicates);
    if (present_column_predicates)
      list.add(column_predicates);

    boolean present_do_not_cache = true && (isSetDo_not_cache());
    list.add(present_do_not_cache);
    if (present_do_not_cache)
      list.add(do_not_cache);

    return list.hashCode();
  }

  @Override
  public int compareTo(ScanSpec other) {
    if (!getClass().equals(other.getClass())) {
      return getClass().getName().compareTo(other.getClass().getName());
    }

    int lastComparison = 0;

    lastComparison = Boolean.valueOf(isSetRow_intervals()).compareTo(other.isSetRow_intervals());
    if (lastComparison != 0) {
      return lastComparison;
    }
    if (isSetRow_intervals()) {
      lastComparison = org.apache.thrift.TBaseHelper.compareTo(this.row_intervals, other.row_intervals);
      if (lastComparison != 0) {
        return lastComparison;
      }
    }
    lastComparison = Boolean.valueOf(isSetCell_intervals()).compareTo(other.isSetCell_intervals());
    if (lastComparison != 0) {
      return lastComparison;
    }
    if (isSetCell_intervals()) {
      lastComparison = org.apache.thrift.TBaseHelper.compareTo(this.cell_intervals, other.cell_intervals);
      if (lastComparison != 0) {
        return lastComparison;
      }
    }
    lastComparison = Boolean.valueOf(isSetReturn_deletes()).compareTo(other.isSetReturn_deletes());
    if (lastComparison != 0) {
      return lastComparison;
    }
    if (isSetReturn_deletes()) {
      lastComparison = org.apache.thrift.TBaseHelper.compareTo(this.return_deletes, other.return_deletes);
      if (lastComparison != 0) {
        return lastComparison;
      }
    }
    lastComparison = Boolean.valueOf(isSetVersions()).compareTo(other.isSetVersions());
    if (lastComparison != 0) {
      return lastComparison;
    }
    if (isSetVersions()) {
      lastComparison = org.apache.thrift.TBaseHelper.compareTo(this.versions, other.versions);
      if (lastComparison != 0) {
        return lastComparison;
      }
    }
    lastComparison = Boolean.valueOf(isSetRow_limit()).compareTo(other.isSetRow_limit());
    if (lastComparison != 0) {
      return lastComparison;
    }
    if (isSetRow_limit()) {
      lastComparison = org.apache.thrift.TBaseHelper.compareTo(this.row_limit, other.row_limit);
      if (lastComparison != 0) {
        return lastComparison;
      }
    }
    lastComparison = Boolean.valueOf(isSetStart_time()).compareTo(other.isSetStart_time());
    if (lastComparison != 0) {
      return lastComparison;
    }
    if (isSetStart_time()) {
      lastComparison = org.apache.thrift.TBaseHelper.compareTo(this.start_time, other.start_time);
      if (lastComparison != 0) {
        return lastComparison;
      }
    }
    lastComparison = Boolean.valueOf(isSetEnd_time()).compareTo(other.isSetEnd_time());
    if (lastComparison != 0) {
      return lastComparison;
    }
    if (isSetEnd_time()) {
      lastComparison = org.apache.thrift.TBaseHelper.compareTo(this.end_time, other.end_time);
      if (lastComparison != 0) {
        return lastComparison;
      }
    }
    lastComparison = Boolean.valueOf(isSetColumns()).compareTo(other.isSetColumns());
    if (lastComparison != 0) {
      return lastComparison;
    }
    if (isSetColumns()) {
      lastComparison = org.apache.thrift.TBaseHelper.compareTo(this.columns, other.columns);
      if (lastComparison != 0) {
        return lastComparison;
      }
    }
    lastComparison = Boolean.valueOf(isSetKeys_only()).compareTo(other.isSetKeys_only());
    if (lastComparison != 0) {
      return lastComparison;
    }
    if (isSetKeys_only()) {
      lastComparison = org.apache.thrift.TBaseHelper.compareTo(this.keys_only, other.keys_only);
      if (lastComparison != 0) {
        return lastComparison;
      }
    }
    lastComparison = Boolean.valueOf(isSetCell_limit()).compareTo(other.isSetCell_limit());
    if (lastComparison != 0) {
      return lastComparison;
    }
    if (isSetCell_limit()) {
      lastComparison = org.apache.thrift.TBaseHelper.compareTo(this.cell_limit, other.cell_limit);
      if (lastComparison != 0) {
        return lastComparison;
      }
    }
    lastComparison = Boolean.valueOf(isSetCell_limit_per_family()).compareTo(other.isSetCell_limit_per_family());
    if (lastComparison != 0) {
      return lastComparison;
    }
    if (isSetCell_limit_per_family()) {
      lastComparison = org.apache.thrift.TBaseHelper.compareTo(this.cell_limit_per_family, other.cell_limit_per_family);
      if (lastComparison != 0) {
        return lastComparison;
      }
    }
    lastComparison = Boolean.valueOf(isSetRow_regexp()).compareTo(other.isSetRow_regexp());
    if (lastComparison != 0) {
      return lastComparison;
    }
    if (isSetRow_regexp()) {
      lastComparison = org.apache.thrift.TBaseHelper.compareTo(this.row_regexp, other.row_regexp);
      if (lastComparison != 0) {
        return lastComparison;
      }
    }
    lastComparison = Boolean.valueOf(isSetValue_regexp()).compareTo(other.isSetValue_regexp());
    if (lastComparison != 0) {
      return lastComparison;
    }
    if (isSetValue_regexp()) {
      lastComparison = org.apache.thrift.TBaseHelper.compareTo(this.value_regexp, other.value_regexp);
      if (lastComparison != 0) {
        return lastComparison;
      }
    }
    lastComparison = Boolean.valueOf(isSetScan_and_filter_rows()).compareTo(other.isSetScan_and_filter_rows());
    if (lastComparison != 0) {
      return lastComparison;
    }
    if (isSetScan_and_filter_rows()) {
      lastComparison = org.apache.thrift.TBaseHelper.compareTo(this.scan_and_filter_rows, other.scan_and_filter_rows);
      if (lastComparison != 0) {
        return lastComparison;
      }
    }
    lastComparison = Boolean.valueOf(isSetRow_offset()).compareTo(other.isSetRow_offset());
    if (lastComparison != 0) {
      return lastComparison;
    }
    if (isSetRow_offset()) {
      lastComparison = org.apache.thrift.TBaseHelper.compareTo(this.row_offset, other.row_offset);
      if (lastComparison != 0) {
        return lastComparison;
      }
    }
    lastComparison = Boolean.valueOf(isSetCell_offset()).compareTo(other.isSetCell_offset());
    if (lastComparison != 0) {
      return lastComparison;
    }
    if (isSetCell_offset()) {
      lastComparison = org.apache.thrift.TBaseHelper.compareTo(this.cell_offset, other.cell_offset);
      if (lastComparison != 0) {
        return lastComparison;
      }
    }
    lastComparison = Boolean.valueOf(isSetColumn_predicates()).compareTo(other.isSetColumn_predicates());
    if (lastComparison != 0) {
      return lastComparison;
    }
    if (isSetColumn_predicates()) {
      lastComparison = org.apache.thrift.TBaseHelper.compareTo(this.column_predicates, other.column_predicates);
      if (lastComparison != 0) {
        return lastComparison;
      }
    }
    lastComparison = Boolean.valueOf(isSetDo_not_cache()).compareTo(other.isSetDo_not_cache());
    if (lastComparison != 0) {
      return lastComparison;
    }
    if (isSetDo_not_cache()) {
      lastComparison = org.apache.thrift.TBaseHelper.compareTo(this.do_not_cache, other.do_not_cache);
      if (lastComparison != 0) {
        return lastComparison;
      }
    }
    return 0;
  }

  public _Fields fieldForId(int fieldId) {
    return _Fields.findByThriftId(fieldId);
  }

  public void read(org.apache.thrift.protocol.TProtocol iprot) throws org.apache.thrift.TException {
    schemes.get(iprot.getScheme()).getScheme().read(iprot, this);
  }

  public void write(org.apache.thrift.protocol.TProtocol oprot) throws org.apache.thrift.TException {
    schemes.get(oprot.getScheme()).getScheme().write(oprot, this);
  }

  @Override
  public String toString() {
    StringBuilder sb = new StringBuilder("ScanSpec(");
    boolean first = true;

    if (isSetRow_intervals()) {
      sb.append("row_intervals:");
      if (this.row_intervals == null) {
        sb.append("null");
      } else {
        sb.append(this.row_intervals);
      }
      first = false;
    }
    if (isSetCell_intervals()) {
      if (!first) sb.append(", ");
      sb.append("cell_intervals:");
      if (this.cell_intervals == null) {
        sb.append("null");
      } else {
        sb.append(this.cell_intervals);
      }
      first = false;
    }
    if (isSetReturn_deletes()) {
      if (!first) sb.append(", ");
      sb.append("return_deletes:");
      sb.append(this.return_deletes);
      first = false;
    }
    if (isSetVersions()) {
      if (!first) sb.append(", ");
      sb.append("versions:");
      sb.append(this.versions);
      first = false;
    }
    if (isSetRow_limit()) {
      if (!first) sb.append(", ");
      sb.append("row_limit:");
      sb.append(this.row_limit);
      first = false;
    }
    if (isSetStart_time()) {
      if (!first) sb.append(", ");
      sb.append("start_time:");
      sb.append(this.start_time);
      first = false;
    }
    if (isSetEnd_time()) {
      if (!first) sb.append(", ");
      sb.append("end_time:");
      sb.append(this.end_time);
      first = false;
    }
    if (isSetColumns()) {
      if (!first) sb.append(", ");
      sb.append("columns:");
      if (this.columns == null) {
        sb.append("null");
      } else {
        sb.append(this.columns);
      }
      first = false;
    }
    if (isSetKeys_only()) {
      if (!first) sb.append(", ");
      sb.append("keys_only:");
      sb.append(this.keys_only);
      first = false;
    }
    if (isSetCell_limit()) {
      if (!first) sb.append(", ");
      sb.append("cell_limit:");
      sb.append(this.cell_limit);
      first = false;
    }
    if (isSetCell_limit_per_family()) {
      if (!first) sb.append(", ");
      sb.append("cell_limit_per_family:");
      sb.append(this.cell_limit_per_family);
      first = false;
    }
    if (isSetRow_regexp()) {
      if (!first) sb.append(", ");
      sb.append("row_regexp:");
      if (this.row_regexp == null) {
        sb.append("null");
      } else {
        sb.append(this.row_regexp);
      }
      first = false;
    }
    if (isSetValue_regexp()) {
      if (!first) sb.append(", ");
      sb.append("value_regexp:");
      if (this.value_regexp == null) {
        sb.append("null");
      } else {
        sb.append(this.value_regexp);
      }
      first = false;
    }
    if (isSetScan_and_filter_rows()) {
      if (!first) sb.append(", ");
      sb.append("scan_and_filter_rows:");
      sb.append(this.scan_and_filter_rows);
      first = false;
    }
    if (isSetRow_offset()) {
      if (!first) sb.append(", ");
      sb.append("row_offset:");
      sb.append(this.row_offset);
      first = false;
    }
    if (isSetCell_offset()) {
      if (!first) sb.append(", ");
      sb.append("cell_offset:");
      sb.append(this.cell_offset);
      first = false;
    }
    if (isSetColumn_predicates()) {
      if (!first) sb.append(", ");
      sb.append("column_predicates:");
      if (this.column_predicates == null) {
        sb.append("null");
      } else {
        sb.append(this.column_predicates);
      }
      first = false;
    }
    if (isSetDo_not_cache()) {
      if (!first) sb.append(", ");
      sb.append("do_not_cache:");
      sb.append(this.do_not_cache);
      first = false;
    }
    sb.append(")");
    return sb.toString();
  }

  public void validate() throws org.apache.thrift.TException {
    // check for required fields
    // check for sub-struct validity
  }

  private void writeObject(java.io.ObjectOutputStream out) throws java.io.IOException {
    try {
      write(new org.apache.thrift.protocol.TCompactProtocol(new org.apache.thrift.transport.TIOStreamTransport(out)));
    } catch (org.apache.thrift.TException te) {
      throw new java.io.IOException(te);
    }
  }

  private void readObject(java.io.ObjectInputStream in) throws java.io.IOException, ClassNotFoundException {
    try {
      // it doesn't seem like you should have to do this, but java serialization is wacky, and doesn't call the default constructor.
      __isset_bitfield = 0;
      read(new org.apache.thrift.protocol.TCompactProtocol(new org.apache.thrift.transport.TIOStreamTransport(in)));
    } catch (org.apache.thrift.TException te) {
      throw new java.io.IOException(te);
    }
  }

  private static class ScanSpecStandardSchemeFactory implements SchemeFactory {
    public ScanSpecStandardScheme getScheme() {
      return new ScanSpecStandardScheme();
    }
  }

  private static class ScanSpecStandardScheme extends StandardScheme<ScanSpec> {

    public void read(org.apache.thrift.protocol.TProtocol iprot, ScanSpec struct) throws org.apache.thrift.TException {
      org.apache.thrift.protocol.TField schemeField;
      iprot.readStructBegin();
      while (true)
      {
        schemeField = iprot.readFieldBegin();
        if (schemeField.type == org.apache.thrift.protocol.TType.STOP) { 
          break;
        }
        switch (schemeField.id) {
          case 1: // ROW_INTERVALS
            if (schemeField.type == org.apache.thrift.protocol.TType.LIST) {
              {
                org.apache.thrift.protocol.TList _list0 = iprot.readListBegin();
                struct.row_intervals = new ArrayList<RowInterval>(_list0.size);
                RowInterval _elem1;
                for (int _i2 = 0; _i2 < _list0.size; ++_i2)
                {
                  _elem1 = new RowInterval();
                  _elem1.read(iprot);
                  struct.row_intervals.add(_elem1);
                }
                iprot.readListEnd();
              }
              struct.setRow_intervalsIsSet(true);
            } else { 
              org.apache.thrift.protocol.TProtocolUtil.skip(iprot, schemeField.type);
            }
            break;
          case 2: // CELL_INTERVALS
            if (schemeField.type == org.apache.thrift.protocol.TType.LIST) {
              {
                org.apache.thrift.protocol.TList _list3 = iprot.readListBegin();
                struct.cell_intervals = new ArrayList<CellInterval>(_list3.size);
                CellInterval _elem4;
                for (int _i5 = 0; _i5 < _list3.size; ++_i5)
                {
                  _elem4 = new CellInterval();
                  _elem4.read(iprot);
                  struct.cell_intervals.add(_elem4);
                }
                iprot.readListEnd();
              }
              struct.setCell_intervalsIsSet(true);
            } else { 
              org.apache.thrift.protocol.TProtocolUtil.skip(iprot, schemeField.type);
            }
            break;
          case 3: // RETURN_DELETES
            if (schemeField.type == org.apache.thrift.protocol.TType.BOOL) {
              struct.return_deletes = iprot.readBool();
              struct.setReturn_deletesIsSet(true);
            } else { 
              org.apache.thrift.protocol.TProtocolUtil.skip(iprot, schemeField.type);
            }
            break;
          case 4: // VERSIONS
            if (schemeField.type == org.apache.thrift.protocol.TType.I32) {
              struct.versions = iprot.readI32();
              struct.setVersionsIsSet(true);
            } else { 
              org.apache.thrift.protocol.TProtocolUtil.skip(iprot, schemeField.type);
            }
            break;
          case 5: // ROW_LIMIT
            if (schemeField.type == org.apache.thrift.protocol.TType.I32) {
              struct.row_limit = iprot.readI32();
              struct.setRow_limitIsSet(true);
            } else { 
              org.apache.thrift.protocol.TProtocolUtil.skip(iprot, schemeField.type);
            }
            break;
          case 6: // START_TIME
            if (schemeField.type == org.apache.thrift.protocol.TType.I64) {
              struct.start_time = iprot.readI64();
              struct.setStart_timeIsSet(true);
            } else { 
              org.apache.thrift.protocol.TProtocolUtil.skip(iprot, schemeField.type);
            }
            break;
          case 7: // END_TIME
            if (schemeField.type == org.apache.thrift.protocol.TType.I64) {
              struct.end_time = iprot.readI64();
              struct.setEnd_timeIsSet(true);
            } else { 
              org.apache.thrift.protocol.TProtocolUtil.skip(iprot, schemeField.type);
            }
            break;
          case 8: // COLUMNS
            if (schemeField.type == org.apache.thrift.protocol.TType.LIST) {
              {
                org.apache.thrift.protocol.TList _list6 = iprot.readListBegin();
                struct.columns = new ArrayList<String>(_list6.size);
                String _elem7;
                for (int _i8 = 0; _i8 < _list6.size; ++_i8)
                {
                  _elem7 = iprot.readString();
                  struct.columns.add(_elem7);
                }
                iprot.readListEnd();
              }
              struct.setColumnsIsSet(true);
            } else { 
              org.apache.thrift.protocol.TProtocolUtil.skip(iprot, schemeField.type);
            }
            break;
          case 9: // KEYS_ONLY
            if (schemeField.type == org.apache.thrift.protocol.TType.BOOL) {
              struct.keys_only = iprot.readBool();
              struct.setKeys_onlyIsSet(true);
            } else { 
              org.apache.thrift.protocol.TProtocolUtil.skip(iprot, schemeField.type);
            }
            break;
          case 14: // CELL_LIMIT
            if (schemeField.type == org.apache.thrift.protocol.TType.I32) {
              struct.cell_limit = iprot.readI32();
              struct.setCell_limitIsSet(true);
            } else { 
              org.apache.thrift.protocol.TProtocolUtil.skip(iprot, schemeField.type);
            }
            break;
          case 10: // CELL_LIMIT_PER_FAMILY
            if (schemeField.type == org.apache.thrift.protocol.TType.I32) {
              struct.cell_limit_per_family = iprot.readI32();
              struct.setCell_limit_per_familyIsSet(true);
            } else { 
              org.apache.thrift.protocol.TProtocolUtil.skip(iprot, schemeField.type);
            }
            break;
          case 11: // ROW_REGEXP
            if (schemeField.type == org.apache.thrift.protocol.TType.STRING) {
              struct.row_regexp = iprot.readString();
              struct.setRow_regexpIsSet(true);
            } else { 
              org.apache.thrift.protocol.TProtocolUtil.skip(iprot, schemeField.type);
            }
            break;
          case 12: // VALUE_REGEXP
            if (schemeField.type == org.apache.thrift.protocol.TType.STRING) {
              struct.value_regexp = iprot.readString();
              struct.setValue_regexpIsSet(true);
            } else { 
              org.apache.thrift.protocol.TProtocolUtil.skip(iprot, schemeField.type);
            }
            break;
          case 13: // SCAN_AND_FILTER_ROWS
            if (schemeField.type == org.apache.thrift.protocol.TType.BOOL) {
              struct.scan_and_filter_rows = iprot.readBool();
              struct.setScan_and_filter_rowsIsSet(true);
            } else { 
              org.apache.thrift.protocol.TProtocolUtil.skip(iprot, schemeField.type);
            }
            break;
          case 15: // ROW_OFFSET
            if (schemeField.type == org.apache.thrift.protocol.TType.I32) {
              struct.row_offset = iprot.readI32();
              struct.setRow_offsetIsSet(true);
            } else { 
              org.apache.thrift.protocol.TProtocolUtil.skip(iprot, schemeField.type);
            }
            break;
          case 16: // CELL_OFFSET
            if (schemeField.type == org.apache.thrift.protocol.TType.I32) {
              struct.cell_offset = iprot.readI32();
              struct.setCell_offsetIsSet(true);
            } else { 
              org.apache.thrift.protocol.TProtocolUtil.skip(iprot, schemeField.type);
            }
            break;
          case 17: // COLUMN_PREDICATES
            if (schemeField.type == org.apache.thrift.protocol.TType.LIST) {
              {
                org.apache.thrift.protocol.TList _list9 = iprot.readListBegin();
                struct.column_predicates = new ArrayList<ColumnPredicate>(_list9.size);
                ColumnPredicate _elem10;
                for (int _i11 = 0; _i11 < _list9.size; ++_i11)
                {
                  _elem10 = new ColumnPredicate();
                  _elem10.read(iprot);
                  struct.column_predicates.add(_elem10);
                }
                iprot.readListEnd();
              }
              struct.setColumn_predicatesIsSet(true);
            } else { 
              org.apache.thrift.protocol.TProtocolUtil.skip(iprot, schemeField.type);
            }
            break;
          case 18: // DO_NOT_CACHE
            if (schemeField.type == org.apache.thrift.protocol.TType.BOOL) {
              struct.do_not_cache = iprot.readBool();
              struct.setDo_not_cacheIsSet(true);
            } else { 
              org.apache.thrift.protocol.TProtocolUtil.skip(iprot, schemeField.type);
            }
            break;
          default:
            org.apache.thrift.protocol.TProtocolUtil.skip(iprot, schemeField.type);
        }
        iprot.readFieldEnd();
      }
      iprot.readStructEnd();

      // check for required fields of primitive type, which can't be checked in the validate method
      struct.validate();
    }

    public void write(org.apache.thrift.protocol.TProtocol oprot, ScanSpec struct) throws org.apache.thrift.TException {
      struct.validate();

      oprot.writeStructBegin(STRUCT_DESC);
      if (struct.row_intervals != null) {
        if (struct.isSetRow_intervals()) {
          oprot.writeFieldBegin(ROW_INTERVALS_FIELD_DESC);
          {
            oprot.writeListBegin(new org.apache.thrift.protocol.TList(org.apache.thrift.protocol.TType.STRUCT, struct.row_intervals.size()));
            for (RowInterval _iter12 : struct.row_intervals)
            {
              _iter12.write(oprot);
            }
            oprot.writeListEnd();
          }
          oprot.writeFieldEnd();
        }
      }
      if (struct.cell_intervals != null) {
        if (struct.isSetCell_intervals()) {
          oprot.writeFieldBegin(CELL_INTERVALS_FIELD_DESC);
          {
            oprot.writeListBegin(new org.apache.thrift.protocol.TList(org.apache.thrift.protocol.TType.STRUCT, struct.cell_intervals.size()));
            for (CellInterval _iter13 : struct.cell_intervals)
            {
              _iter13.write(oprot);
            }
            oprot.writeListEnd();
          }
          oprot.writeFieldEnd();
        }
      }
      if (struct.isSetReturn_deletes()) {
        oprot.writeFieldBegin(RETURN_DELETES_FIELD_DESC);
        oprot.writeBool(struct.return_deletes);
        oprot.writeFieldEnd();
      }
      if (struct.isSetVersions()) {
        oprot.writeFieldBegin(VERSIONS_FIELD_DESC);
        oprot.writeI32(struct.versions);
        oprot.writeFieldEnd();
      }
      if (struct.isSetRow_limit()) {
        oprot.writeFieldBegin(ROW_LIMIT_FIELD_DESC);
        oprot.writeI32(struct.row_limit);
        oprot.writeFieldEnd();
      }
      if (struct.isSetStart_time()) {
        oprot.writeFieldBegin(START_TIME_FIELD_DESC);
        oprot.writeI64(struct.start_time);
        oprot.writeFieldEnd();
      }
      if (struct.isSetEnd_time()) {
        oprot.writeFieldBegin(END_TIME_FIELD_DESC);
        oprot.writeI64(struct.end_time);
        oprot.writeFieldEnd();
      }
      if (struct.columns != null) {
        if (struct.isSetColumns()) {
          oprot.writeFieldBegin(COLUMNS_FIELD_DESC);
          {
            oprot.writeListBegin(new org.apache.thrift.protocol.TList(org.apache.thrift.protocol.TType.STRING, struct.columns.size()));
            for (String _iter14 : struct.columns)
            {
              oprot.writeString(_iter14);
            }
            oprot.writeListEnd();
          }
          oprot.writeFieldEnd();
        }
      }
      if (struct.isSetKeys_only()) {
        oprot.writeFieldBegin(KEYS_ONLY_FIELD_DESC);
        oprot.writeBool(struct.keys_only);
        oprot.writeFieldEnd();
      }
      if (struct.isSetCell_limit_per_family()) {
        oprot.writeFieldBegin(CELL_LIMIT_PER_FAMILY_FIELD_DESC);
        oprot.writeI32(struct.cell_limit_per_family);
        oprot.writeFieldEnd();
      }
      if (struct.row_regexp != null) {
        if (struct.isSetRow_regexp()) {
          oprot.writeFieldBegin(ROW_REGEXP_FIELD_DESC);
          oprot.writeString(struct.row_regexp);
          oprot.writeFieldEnd();
        }
      }
      if (struct.value_regexp != null) {
        if (struct.isSetValue_regexp()) {
          oprot.writeFieldBegin(VALUE_REGEXP_FIELD_DESC);
          oprot.writeString(struct.value_regexp);
          oprot.writeFieldEnd();
        }
      }
      if (struct.isSetScan_and_filter_rows()) {
        oprot.writeFieldBegin(SCAN_AND_FILTER_ROWS_FIELD_DESC);
        oprot.writeBool(struct.scan_and_filter_rows);
        oprot.writeFieldEnd();
      }
      if (struct.isSetCell_limit()) {
        oprot.writeFieldBegin(CELL_LIMIT_FIELD_DESC);
        oprot.writeI32(struct.cell_limit);
        oprot.writeFieldEnd();
      }
      if (struct.isSetRow_offset()) {
        oprot.writeFieldBegin(ROW_OFFSET_FIELD_DESC);
        oprot.writeI32(struct.row_offset);
        oprot.writeFieldEnd();
      }
      if (struct.isSetCell_offset()) {
        oprot.writeFieldBegin(CELL_OFFSET_FIELD_DESC);
        oprot.writeI32(struct.cell_offset);
        oprot.writeFieldEnd();
      }
      if (struct.column_predicates != null) {
        if (struct.isSetColumn_predicates()) {
          oprot.writeFieldBegin(COLUMN_PREDICATES_FIELD_DESC);
          {
            oprot.writeListBegin(new org.apache.thrift.protocol.TList(org.apache.thrift.protocol.TType.STRUCT, struct.column_predicates.size()));
            for (ColumnPredicate _iter15 : struct.column_predicates)
            {
              _iter15.write(oprot);
            }
            oprot.writeListEnd();
          }
          oprot.writeFieldEnd();
        }
      }
      if (struct.isSetDo_not_cache()) {
        oprot.writeFieldBegin(DO_NOT_CACHE_FIELD_DESC);
        oprot.writeBool(struct.do_not_cache);
        oprot.writeFieldEnd();
      }
      oprot.writeFieldStop();
      oprot.writeStructEnd();
    }

  }

  private static class ScanSpecTupleSchemeFactory implements SchemeFactory {
    public ScanSpecTupleScheme getScheme() {
      return new ScanSpecTupleScheme();
    }
  }

  private static class ScanSpecTupleScheme extends TupleScheme<ScanSpec> {

    @Override
    public void write(org.apache.thrift.protocol.TProtocol prot, ScanSpec struct) throws org.apache.thrift.TException {
      TTupleProtocol oprot = (TTupleProtocol) prot;
      BitSet optionals = new BitSet();
      if (struct.isSetRow_intervals()) {
        optionals.set(0);
      }
      if (struct.isSetCell_intervals()) {
        optionals.set(1);
      }
      if (struct.isSetReturn_deletes()) {
        optionals.set(2);
      }
      if (struct.isSetVersions()) {
        optionals.set(3);
      }
      if (struct.isSetRow_limit()) {
        optionals.set(4);
      }
      if (struct.isSetStart_time()) {
        optionals.set(5);
      }
      if (struct.isSetEnd_time()) {
        optionals.set(6);
      }
      if (struct.isSetColumns()) {
        optionals.set(7);
      }
      if (struct.isSetKeys_only()) {
        optionals.set(8);
      }
      if (struct.isSetCell_limit()) {
        optionals.set(9);
      }
      if (struct.isSetCell_limit_per_family()) {
        optionals.set(10);
      }
      if (struct.isSetRow_regexp()) {
        optionals.set(11);
      }
      if (struct.isSetValue_regexp()) {
        optionals.set(12);
      }
      if (struct.isSetScan_and_filter_rows()) {
        optionals.set(13);
      }
      if (struct.isSetRow_offset()) {
        optionals.set(14);
      }
      if (struct.isSetCell_offset()) {
        optionals.set(15);
      }
      if (struct.isSetColumn_predicates()) {
        optionals.set(16);
      }
      if (struct.isSetDo_not_cache()) {
        optionals.set(17);
      }
      oprot.writeBitSet(optionals, 18);
      if (struct.isSetRow_intervals()) {
        {
          oprot.writeI32(struct.row_intervals.size());
          for (RowInterval _iter16 : struct.row_intervals)
          {
            _iter16.write(oprot);
          }
        }
      }
      if (struct.isSetCell_intervals()) {
        {
          oprot.writeI32(struct.cell_intervals.size());
          for (CellInterval _iter17 : struct.cell_intervals)
          {
            _iter17.write(oprot);
          }
        }
      }
      if (struct.isSetReturn_deletes()) {
        oprot.writeBool(struct.return_deletes);
      }
      if (struct.isSetVersions()) {
        oprot.writeI32(struct.versions);
      }
      if (struct.isSetRow_limit()) {
        oprot.writeI32(struct.row_limit);
      }
      if (struct.isSetStart_time()) {
        oprot.writeI64(struct.start_time);
      }
      if (struct.isSetEnd_time()) {
        oprot.writeI64(struct.end_time);
      }
      if (struct.isSetColumns()) {
        {
          oprot.writeI32(struct.columns.size());
          for (String _iter18 : struct.columns)
          {
            oprot.writeString(_iter18);
          }
        }
      }
      if (struct.isSetKeys_only()) {
        oprot.writeBool(struct.keys_only);
      }
      if (struct.isSetCell_limit()) {
        oprot.writeI32(struct.cell_limit);
      }
      if (struct.isSetCell_limit_per_family()) {
        oprot.writeI32(struct.cell_limit_per_family);
      }
      if (struct.isSetRow_regexp()) {
        oprot.writeString(struct.row_regexp);
      }
      if (struct.isSetValue_regexp()) {
        oprot.writeString(struct.value_regexp);
      }
      if (struct.isSetScan_and_filter_rows()) {
        oprot.writeBool(struct.scan_and_filter_rows);
      }
      if (struct.isSetRow_offset()) {
        oprot.writeI32(struct.row_offset);
      }
      if (struct.isSetCell_offset()) {
        oprot.writeI32(struct.cell_offset);
      }
      if (struct.isSetColumn_predicates()) {
        {
          oprot.writeI32(struct.column_predicates.size());
          for (ColumnPredicate _iter19 : struct.column_predicates)
          {
            _iter19.write(oprot);
          }
        }
      }
      if (struct.isSetDo_not_cache()) {
        oprot.writeBool(struct.do_not_cache);
      }
    }

    @Override
    public void read(org.apache.thrift.protocol.TProtocol prot, ScanSpec struct) throws org.apache.thrift.TException {
      TTupleProtocol iprot = (TTupleProtocol) prot;
      BitSet incoming = iprot.readBitSet(18);
      if (incoming.get(0)) {
        {
          org.apache.thrift.protocol.TList _list20 = new org.apache.thrift.protocol.TList(org.apache.thrift.protocol.TType.STRUCT, iprot.readI32());
          struct.row_intervals = new ArrayList<RowInterval>(_list20.size);
          RowInterval _elem21;
          for (int _i22 = 0; _i22 < _list20.size; ++_i22)
          {
            _elem21 = new RowInterval();
            _elem21.read(iprot);
            struct.row_intervals.add(_elem21);
          }
        }
        struct.setRow_intervalsIsSet(true);
      }
      if (incoming.get(1)) {
        {
          org.apache.thrift.protocol.TList _list23 = new org.apache.thrift.protocol.TList(org.apache.thrift.protocol.TType.STRUCT, iprot.readI32());
          struct.cell_intervals = new ArrayList<CellInterval>(_list23.size);
          CellInterval _elem24;
          for (int _i25 = 0; _i25 < _list23.size; ++_i25)
          {
            _elem24 = new CellInterval();
            _elem24.read(iprot);
            struct.cell_intervals.add(_elem24);
          }
        }
        struct.setCell_intervalsIsSet(true);
      }
      if (incoming.get(2)) {
        struct.return_deletes = iprot.readBool();
        struct.setReturn_deletesIsSet(true);
      }
      if (incoming.get(3)) {
        struct.versions = iprot.readI32();
        struct.setVersionsIsSet(true);
      }
      if (incoming.get(4)) {
        struct.row_limit = iprot.readI32();
        struct.setRow_limitIsSet(true);
      }
      if (incoming.get(5)) {
        struct.start_time = iprot.readI64();
        struct.setStart_timeIsSet(true);
      }
      if (incoming.get(6)) {
        struct.end_time = iprot.readI64();
        struct.setEnd_timeIsSet(true);
      }
      if (incoming.get(7)) {
        {
          org.apache.thrift.protocol.TList _list26 = new org.apache.thrift.protocol.TList(org.apache.thrift.protocol.TType.STRING, iprot.readI32());
          struct.columns = new ArrayList<String>(_list26.size);
          String _elem27;
          for (int _i28 = 0; _i28 < _list26.size; ++_i28)
          {
            _elem27 = iprot.readString();
            struct.columns.add(_elem27);
          }
        }
        struct.setColumnsIsSet(true);
      }
      if (incoming.get(8)) {
        struct.keys_only = iprot.readBool();
        struct.setKeys_onlyIsSet(true);
      }
      if (incoming.get(9)) {
        struct.cell_limit = iprot.readI32();
        struct.setCell_limitIsSet(true);
      }
      if (incoming.get(10)) {
        struct.cell_limit_per_family = iprot.readI32();
        struct.setCell_limit_per_familyIsSet(true);
      }
      if (incoming.get(11)) {
        struct.row_regexp = iprot.readString();
        struct.setRow_regexpIsSet(true);
      }
      if (incoming.get(12)) {
        struct.value_regexp = iprot.readString();
        struct.setValue_regexpIsSet(true);
      }
      if (incoming.get(13)) {
        struct.scan_and_filter_rows = iprot.readBool();
        struct.setScan_and_filter_rowsIsSet(true);
      }
      if (incoming.get(14)) {
        struct.row_offset = iprot.readI32();
        struct.setRow_offsetIsSet(true);
      }
      if (incoming.get(15)) {
        struct.cell_offset = iprot.readI32();
        struct.setCell_offsetIsSet(true);
      }
      if (incoming.get(16)) {
        {
          org.apache.thrift.protocol.TList _list29 = new org.apache.thrift.protocol.TList(org.apache.thrift.protocol.TType.STRUCT, iprot.readI32());
          struct.column_predicates = new ArrayList<ColumnPredicate>(_list29.size);
          ColumnPredicate _elem30;
          for (int _i31 = 0; _i31 < _list29.size; ++_i31)
          {
            _elem30 = new ColumnPredicate();
            _elem30.read(iprot);
            struct.column_predicates.add(_elem30);
          }
        }
        struct.setColumn_predicatesIsSet(true);
      }
      if (incoming.get(17)) {
        struct.do_not_cache = iprot.readBool();
        struct.setDo_not_cacheIsSet(true);
      }
    }
  }

}

